package protocols

import "encoding/binary"

type IPHeader struct {
	// Версия IP (4,6)
	Version uint8 // 0-3 бита
	// Длина заголовка (Internet Header Length)
	IHL uint8 // 4-7 бита
	// Определяет приоритет и тип обслуживания пакета
	TypeOfService uint8 // 4-й байт
	// Общая длина пакета
	TotalLength uint16 // 2 байта
	// Идентификатор пакета, который используется для фрагментации и сборки фрагментов пакетов.
	// Все фрагменты одного пакета будут иметь одинаковый идентификатор.
	Identification uint16 // 2 байта
	// Флаги, используемые при фрагментации
	// Смещение фрагмента относительно начала оригинального пакета в 8-байтовых блоках
	FlagsFragOffset uint16 // 2 байта
	// Время жизни пакета
	TTL uint8 // 1 байт
	// Протокол в верхнем уровне (TCP, UDP, ICMP ...)
	Protocol uint8 // 1 байт
	// Контрольная сумма заголовка IP-пакета для проверки целостности данных.
	//Включает только сам заголовок, а не данные
	Checksum uint16 // 2 байта
	// IP-адрес источника
	SourceIP uint32 // 4 байта
	// IP-адрес назначения
	DestIP uint32 // 4 байта
}

func ParseIPHeader(data []byte) *IPHeader {
	ipHeader := &IPHeader{}
	ipHeader.Version = data[0] >> 4 // сдвигаем старшие 4 бита на место младших вправо
	ipHeader.IHL = data[0] & 0x0F   // оставляем только младшие 4 бита
	ipHeader.TotalLength = binary.BigEndian.Uint16(data[2:4])
	ipHeader.Identification = binary.BigEndian.Uint16(data[4:6])
	ipHeader.FlagsFragOffset = binary.BigEndian.Uint16(data[6:8])
	ipHeader.TTL = data[8]
	ipHeader.Protocol = data[9]
	ipHeader.Checksum = binary.BigEndian.Uint16(data[10:12])
	ipHeader.SourceIP = binary.BigEndian.Uint32(data[12:16])
	ipHeader.DestIP = binary.BigEndian.Uint32(data[16:20])

	return ipHeader
}

// data[0] = 0x45, в двоичном виде:
//
// 0x45 = 0100 0101
//         |    |
//        Vers  IHL
// Version = 0100 = 4 (IPv4)
// IHL = 0101 = 5 (5 * 4 байта = 20 байт заголовка)
//
// Если сделать data[0] >> 4, будет:
//
// 0100 0101 >> 4 = 0000 0100
// То есть останется просто 4 — это и есть версия протокола.
//
// Для того чтобы взять длину заголовка
// IHL := data[0] & 0x0F
// (& 0x0F = побитовая маска на младшие 4 бита)
//
// 'data[0] >> 4' — убираем младшие 4 бита, оставляем только старшие (версию IP).
// 'data[0] & 0x0F' — берем только младшие 4 бита (длину заголовка IHL).
//
// 0x0F — это шестнадцатеричная маска. В двоичной форме она выглядит так:
// 0x0F = 00001111
// data[0] = 11001100
// AND (&) работает по следующему правилу:
// Если оба бита одинаковы (1 и 1), результат будет 1.
// В остальных случаях (0 и 1, 1 и 0, 0 и 0) результат будет 0.
// Тогда:
//   11001100  (data[0])
// & 00001111  (0x0F)
//   --------
//   00001100

// destIP := parsedIpProtocol.DestIP
// ip := net.IPv4(byte(destIP>>24), byte(destIP>>16), byte(destIP>>8), byte(destIP)).String()
// fmt.Println(ip)
// 52.223.194.190
// Выражение	Операция	        Результат в битах	                Байт (8 бит)	Десятичное значение	Какой IP-октет
// DestIP >> 24	сдвиг на 24 вправо	00000000 00000000 00000000 00110100	00110100	    52	                Первый байт (старший)
// DestIP >> 16	сдвиг на 16 вправо	00000000 00000000 00110100 11011111	11011111	    223	                Второй байт
// DestIP >> 8	сдвиг на 8 вправо	00000000 00110100 11011111 11000010	11000010	    194	                Третий байт
// DestIP	    без сдвига	        00110100 11011111 11000010 10111110	10111110	    190	                Четвертый байт (младший)
//
// При сдвиге остаются лишние старшие биты
// Чтобы избавиться от них можно оборачивать выражение в byte(), который оставляет только младшие 8 бит
